#include<iostream>
#include <string>
#include <stack>
#include <cstring>
#include <vector>
#include<ostream>
#include <queue>
#include<functional>
#include<fstream>
#include<iomanip>
#define INF 1e9
using namespace std;

int isNotVisited(int x, vector<int>& path)
{
	int size = path.size();
	for (int i = 0; i < size; i++)
		if (path[i] == x)
			return 0;
	return 1;
}

vector<int> findpaths(vector<vector<int> >&g, int**graph, int src, int dst, int n, int m)
{
	queue<vector<int> > q;
	vector<int> path;
	vector<int> path2;
	vector<vector<int>> curr_paths(n*m);
	vector<int> Dis;
	vector<int>min_i;
	int index = 0;
	int min_index;
	int min = INF;
	path.push_back(src);
	q.push(path);
	while (!q.empty())
	{
		path = q.front();
		q.pop();
		int last = path[path.size() - 1];
		if (last == dst)
		{
			int dis = 0;
			int size = path.size();
			//	curr_paths.resize(n,vector<int>(size));
			for (int i = 0; i < size - 1; i++)
			{
				curr_paths[index].push_back(path[i]);
				dis += graph[path[i]][path[i + 1]];
			}
			curr_paths[index].push_back(path[size - 1]);
			Dis.push_back(dis);
			index++;
			//cout << "size1= " << curr_paths.size() << endl;
			if (index >= curr_paths.size())
				curr_paths.resize(2 * curr_paths.size());
			//cout << "size2= " << curr_paths.size() << endl;
		}

		for (int i = 0; i < g[last].size(); i++)
		{
			if (isNotVisited(g[last][i], path))
			{
				vector<int> newpath(path);
				newpath.push_back(g[last][i]);
				q.push(newpath);
			}
		}
	}
	for (int y = 0; y < Dis.size(); y++)
	{
		if (Dis[y] < min)
		{ 
			min = Dis[y];
			min_index = y;

			while (!min_i.empty())
				min_i.pop_back();
			min_i.push_back(y);
			
		
		}
		else if (Dis[y] == min)
		{
			min_i.push_back(y);
		}
	}
	for (int i = 0; i < min_i.size(); i++)
	{
		for (int j = 0; j < curr_paths[min_i[i]].size(); j++)
		{
			path2.push_back(curr_paths[min_i[i]][j]);

		}
	}


	return path2;
}

int main()
{
	int n, m, A, B, C, count = 0;
	int dis = 0;
	vector <int> path;
	double *arr, *arr2;
	double x;
	int *a, *b, *c;
	cin >> n >> m;
	a = new int[m];
	b = new int[m];
	c = new int[m];

	if ((2 <= n) && (n <= 15) && (n - 1 <= m) && (m <= n * (n - 1) / 2))
	{
		arr = new double[n];
		arr2 = new double[n];
		for (int i = 0; i < n; i++)
		{
			arr[i] = 0;
			arr2[i] = 0;
		}
		vector<vector<int> > g(n);
		int ** graph;
		graph = new int*[n];
		for (int i = 0; i < n; i++)
		{
			graph[i] = new int[n];
			for (int j = 0; j < n; j++)
				graph[i][j] = 0;
		}


		for (int i = 0; i < m; i++)
		{
			cin >> A >> B  >> C;
			a[i] = A;
			b[i] = B;
			c[i] = C;
			g[A].push_back(B);
			g[B].push_back(A);
			graph[A][B] = C;
			graph[B][A] = C;

		}
		//int min = INF;
		for (int i = 0; i < n; i++)
		{

			for (int j = i + 1; j < n; j++)
			{
				count = 0;
				path = findpaths(g, graph, i, j, n, m);
				//for (int i = 0; i < path.size(); i++)
				//cout << path[i] << endl;
				//cout << "*******" << endl;

				if (path.size() > 2)
				{
					for (int u = 0; u < path.size(); u++)
					{
						if (path[u] == i)
							count++;
						if (path[u] != i && path[u] != j)
						{
							for (int d = 0; d < n; d++)
							{
								if (i != d && j != d)
								{
									if (path[u] == d)
									{
										arr2[d] += 1;
									}
								}
							}
						}

					}
					for (int d = 0; d < n; d++)
					{
						arr2[d] = (double)arr2[d] / count;
						arr[d] += arr2[d];
						arr2[d] = 0;
					}
				}
			}
		}
		for (int i = 0; i < n; i++)
		{
			cout << setprecision(12) << fixed;
			cout << arr[i] << '\n';
		}

		ofstream myfile;
		myfile.open("/Users/Galal/source/repos/PythonApplication1/PythonApplication1/sh.txt");
		myfile << n << endl;
		myfile << m << endl;
		for (int i = 0; i < m; i++)
		{
			myfile << a[i] << endl;
			myfile << b[i] << endl;
			myfile << c[i] << endl;
			myfile << (arr[a[i]]+1) << endl;
			myfile << (arr[b[i]]+1) << endl;
		}

		myfile.close();
		//cin >> n;
	}
	return 0;
}
